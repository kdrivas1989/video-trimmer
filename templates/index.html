<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Trimmer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .dropzone {
            border: 2px dashed #cbd5e1;
            transition: all 0.2s;
        }
        .dropzone.dragover {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }
        .progress-bar {
            transition: width 0.3s;
        }
        .modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            z-index: 50;
            align-items: center;
            justify-content: center;
        }
        .modal.active {
            display: flex;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-4xl">
        <h1 class="text-3xl font-bold text-gray-800 mb-8 text-center">Video Trimmer</h1>

        <!-- Upload Area -->
        <div id="dropzone" class="dropzone bg-white rounded-lg p-8 mb-6 text-center cursor-pointer">
            <svg class="mx-auto h-12 w-12 text-gray-400 mb-4" stroke="currentColor" fill="none" viewBox="0 0 48 48">
                <path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
            </svg>
            <p class="text-gray-600 mb-2">Drop video files here</p>
            <p class="text-sm text-gray-400 mb-4">MP4, AVI, MOV, MKV, WMV, FLV, WebM, MTS</p>
            <input type="file" id="fileInput" multiple
                onchange="handleFileSelect(this.files)"
                class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-700 file:cursor-pointer cursor-pointer">
        </div>

        <!-- Video List -->
        <div id="videoListContainer" class="hidden">
            <h2 class="text-lg font-semibold text-gray-700 mb-3">Videos</h2>
            <div id="videoList" class="space-y-3"></div>
        </div>

        <!-- Export Button -->
        <div id="trimAllContainer" class="hidden mt-6 text-center">
            <button onclick="exportCSV()" class="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-3 px-8 rounded-lg transition">
                Export CSV
            </button>
        </div>
    </div>

    <!-- Video Preview Modal -->
    <div id="previewModal" class="modal">
        <div class="bg-white rounded-lg p-3 max-w-3xl w-full mx-2">
            <div class="flex justify-between items-center mb-2 gap-2">
                <input type="text" id="previewFilename" class="flex-1 text-sm font-semibold text-gray-800 border border-gray-300 rounded px-2 py-1 focus:outline-none focus:border-blue-500" />
                <button onclick="closePreview()" class="text-gray-500 hover:text-gray-700 text-xl">&times;</button>
            </div>
            <video id="previewVideo" class="w-full bg-black rounded max-h-[40vh]" controls preload="none" playsinline webkit-playsinline>
                Your browser does not support video playback.
            </video>
            <div id="videoError" class="hidden text-center text-xs mt-1 p-2 bg-orange-50 rounded">
                <p id="previewStatusText" class="text-orange-600">
                    <span class="inline-block animate-spin mr-1">⟳</span> Generating playable preview...
                </p>
            </div>
            <div class="text-center mt-2">
                <button onclick="openVideoInNewTab()" class="text-xs text-blue-600 hover:underline">
                    Video not loading? Open in new tab
                </button>
            </div>
            <div class="mt-2 space-y-2">
                <!-- Current time and trim duration inline -->
                <div class="flex justify-center gap-6 text-sm">
                    <div><span class="text-gray-500">Current:</span> <span id="currentTime" class="font-mono font-semibold">0.000s</span></div>
                    <div><span class="text-gray-500">Total:</span> <span id="videoDuration" class="font-mono font-semibold text-gray-600">--</span></div>
                    <div><span class="text-gray-500">Trim:</span> <span id="previewTrimDuration" class="font-mono font-semibold text-blue-600">0.000s</span></div>
                </div>
                <!-- All buttons in one row -->
                <div class="flex flex-wrap gap-2 items-start justify-center">
                    <div class="flex flex-col gap-1">
                        <button onclick="missedEntryFromPreview()" class="bg-yellow-500 hover:bg-yellow-600 text-white px-3 py-1.5 rounded text-sm font-medium">
                            Missed [ME]
                        </button>
                        <button onclick="canopyDownFromPreview()" class="bg-purple-500 hover:bg-purple-600 text-white px-3 py-1.5 rounded text-sm font-medium">
                            Canopy [C]
                        </button>
                    </div>
                    <div class="text-center">
                        <button onclick="setStartFromPlayer()" class="bg-green-500 hover:bg-green-600 text-white px-4 py-1.5 rounded text-sm font-medium">
                            Start [S]
                        </button>
                        <div class="text-xs text-gray-600"><span id="previewStart" class="font-mono">0.000s</span> <button onclick="jumpToStart()" class="text-green-600 hover:underline">go</button></div>
                    </div>
                    <div class="text-center">
                        <button onclick="setEndFromPlayer()" class="bg-red-500 hover:bg-red-600 text-white px-4 py-1.5 rounded text-sm font-medium">
                            End [E]
                        </button>
                        <div class="text-xs text-gray-600"><span id="previewEnd" class="font-mono">--.---s</span> <button onclick="jumpToEnd()" class="text-red-600 hover:underline">go</button></div>
                    </div>
                    <div class="text-center">
                        <button onclick="flagForReviewFromPreview()" class="bg-orange-500 hover:bg-orange-600 text-white px-4 py-1.5 rounded text-sm font-medium">
                            Flag For Review [F]
                        </button>
                        <div class="text-xs text-gray-600">&nbsp;</div>
                    </div>
                    <div class="text-center">
                        <button onclick="saveTimesOnly()" class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-1.5 rounded text-sm font-medium">
                            Save Times
                        </button>
                        <div class="text-xs text-gray-600">&nbsp;</div>
                    </div>
                    <div class="text-center">
                        <button onclick="saveTimesAndClose()" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-1.5 rounded text-sm font-semibold">
                            Save & Trim
                        </button>
                        <div class="text-xs text-gray-600">&nbsp;</div>
                    </div>
                </div>
                <div class="text-center text-xs text-gray-400">
                    Keys: M/C/F/S/E, Space=Play, ←/→=Frame, Enter=Save Times
                </div>
            </div>
        </div>
    </div>

    <script>
        const dropzone = document.getElementById('dropzone');
        const fileInput = document.getElementById('fileInput');
        const videoList = document.getElementById('videoList');
        const trimAllContainer = document.getElementById('trimAllContainer');

        let videos = {};

        // Drag and drop handlers
        dropzone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropzone.classList.add('dragover');
        });

        dropzone.addEventListener('dragleave', () => {
            dropzone.classList.remove('dragover');
        });

        dropzone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropzone.classList.remove('dragover');
            handleFileSelect(e.dataTransfer.files);
        });

        function handleFileSelect(files) {
            console.log('Files selected:', files.length);
            for (const file of files) {
                console.log('Uploading:', file.name);
                uploadFile(file);
            }
            fileInput.value = ''; // Reset so same file can be selected again
        }

        async function uploadFile(file) {
            const formData = new FormData();
            formData.append('file', file);

            // Create placeholder card
            const tempId = 'temp-' + Date.now();
            addVideoCard(tempId, file.name, 0, '00:00:00', true);

            try {
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });

                const text = await response.text();
                let data;
                try {
                    data = JSON.parse(text);
                } catch (parseError) {
                    throw new Error('Server error: ' + (text || 'No response - file may be too large'));
                }

                if (response.ok) {
                    // Remove placeholder and add real card
                    removeVideoCard(tempId);
                    // Store start and end times
                    data.start_time = data.start_time || '0.000s';
                    data.end_time = data.end_time || data.duration_str;
                    videos[data.id] = data;
                    addVideoCard(data.id, data.filename, data.duration, data.duration_str, false, data.browser_playable);
                    updateTrimAllVisibility();

                    // If not browser playable, poll for transcoding completion
                    if (!data.browser_playable) {
                        pollTranscodeStatus(data.id);
                    }
                } else {
                    removeVideoCard(tempId);
                    alert('Upload failed: ' + data.error);
                }
            } catch (error) {
                removeVideoCard(tempId);
                alert('Upload failed: ' + error.message);
            }
        }

        const videoListContainer = document.getElementById('videoListContainer');

        function addVideoCard(id, filename, duration, durationStr, loading, browserPlayable = true) {
            // Show the container
            videoListContainer.classList.remove('hidden');

            const card = document.createElement('div');
            card.id = `card-${id}`;
            card.className = 'bg-white rounded-lg p-4 shadow border-l-4 border-blue-500';

            if (loading) {
                card.className += ' border-yellow-500';
                card.innerHTML = `
                    <div class="flex items-center justify-between">
                        <div class="flex items-center">
                            <div class="animate-spin rounded-full h-5 w-5 border-b-2 border-blue-600 mr-3"></div>
                            <span class="text-gray-700 font-medium">${filename}</span>
                        </div>
                        <span class="text-sm text-yellow-600 font-medium">Uploading...</span>
                    </div>
                `;
            } else {
                // Get start and end times from video data or defaults
                const startTime = videos[id]?.start_time || '0.000s';
                const endTime = videos[id]?.end_time || durationStr;

                card.innerHTML = `
                    <div class="flex flex-wrap items-center gap-4">
                        <div class="flex-1 min-w-[200px]">
                            <div class="flex items-center gap-2">
                                <input type="text" id="name-${id}" value="${filename.replace(/\.[^/.]+$/, '')}"
                                    class="font-medium text-gray-800 flex-1 border-b border-transparent hover:border-gray-300 focus:border-blue-500 focus:outline-none bg-transparent" title="Click to rename">
                                <button onclick="previewVideo('${id}')" class="bg-purple-600 hover:bg-purple-700 text-white px-3 py-1 rounded text-sm transition">
                                    Preview
                                </button>
                            </div>
                            <p class="text-sm text-gray-500">
                                <span class="font-medium">Duration:</span> ${durationStr}
                                <span class="mx-2">|</span>
                                <span class="text-green-600">Start:</span> <span id="startDisplay-${id}">${startTime}</span>
                                <span class="mx-1">→</span>
                                <span class="text-red-600">End:</span> <span id="endDisplay-${id}">${endTime}</span>
                            </p>
                            <p id="status-${id}" class="text-sm text-green-600 font-medium"></p>
                        </div>
                        <div class="flex items-center gap-2">
                            <label class="text-sm text-gray-600">Start:</label>
                            <input type="text" id="start-${id}" value="${startTime}"
                                class="border rounded px-2 py-1 w-32 text-sm font-mono" placeholder="0.000s"
                                onchange="updateTimeDisplay('${id}')">
                        </div>
                        <div class="flex items-center gap-2">
                            <label class="text-sm text-gray-600">End:</label>
                            <input type="text" id="end-${id}" value="${endTime}"
                                class="border rounded px-2 py-1 w-32 text-sm font-mono" placeholder="0.000s"
                                onchange="updateTimeDisplay('${id}')">
                        </div>
                        <div class="flex gap-2 flex-wrap">
                            <button onclick="deleteVideo('${id}')" class="bg-red-500 hover:bg-red-600 text-white px-4 py-1 rounded text-sm transition">
                                Remove
                            </button>
                        </div>
                    </div>
                    <div id="progress-${id}" class="hidden mt-3">
                        <div class="bg-gray-200 rounded-full h-2">
                            <div id="progressBar-${id}" class="progress-bar bg-blue-600 h-2 rounded-full" style="width: 0%"></div>
                        </div>
                    </div>
                    <div id="error-${id}" class="hidden mt-3">
                        <div class="bg-red-50 border border-red-200 rounded p-2">
                            <div class="flex justify-between items-start gap-2">
                                <textarea id="errorText-${id}" readonly class="flex-1 text-xs text-red-700 bg-transparent resize-none font-mono" rows="2"></textarea>
                                <button onclick="copyError('${id}')" class="text-xs bg-red-100 hover:bg-red-200 text-red-700 px-2 py-1 rounded">Copy</button>
                            </div>
                        </div>
                    </div>
                    <div id="download-${id}" class="hidden mt-3">
                        <a href="/download/${id}" class="inline-flex items-center text-blue-600 hover:text-blue-800 font-medium">
                            <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                            </svg>
                            Download trimmed video
                        </a>
                    </div>
                `;
            }

            videoList.appendChild(card);
        }

        function removeVideoCard(id) {
            const card = document.getElementById(`card-${id}`);
            if (card) card.remove();
        }

        function updateTrimAllVisibility() {
            trimAllContainer.classList.toggle('hidden', Object.keys(videos).length === 0);
        }

        function updateTimeDisplay(id) {
            const startInput = document.getElementById(`start-${id}`);
            const endInput = document.getElementById(`end-${id}`);
            const startDisplay = document.getElementById(`startDisplay-${id}`);
            const endDisplay = document.getElementById(`endDisplay-${id}`);

            if (startInput && startDisplay) {
                startDisplay.textContent = startInput.value;
            }
            if (endInput && endDisplay) {
                endDisplay.textContent = endInput.value;
            }
        }

        function pollTranscodeStatus(id) {
            const statusDiv = document.getElementById(`status-${id}`);
            if (statusDiv) {
                statusDiv.textContent = 'Transcoding for preview...';
                statusDiv.className = 'text-sm text-purple-600 font-medium';
            }

            const checkStatus = async () => {
                try {
                    const res = await fetch(`/preview/status/${id}`);
                    const data = await res.json();

                    if (data.exists) {
                        // Transcoding complete
                        if (statusDiv) {
                            statusDiv.textContent = 'Preview ready';
                            statusDiv.className = 'text-sm text-green-600 font-medium';
                        }
                        if (videos[id]) {
                            videos[id].preview_ready = true;
                        }
                    } else {
                        // Still transcoding, check again in 3 seconds
                        setTimeout(checkStatus, 3000);
                    }
                } catch (e) {
                    // Retry on error
                    setTimeout(checkStatus, 5000);
                }
            };

            // Start polling after 2 seconds
            setTimeout(checkStatus, 2000);
        }

        function showError(id, errorMessage, statusDiv, card, errorDiv, errorText) {
            statusDiv.textContent = 'Error (see details below)';
            statusDiv.className = 'text-sm text-red-600 font-medium';
            card.className = 'bg-white rounded-lg p-4 shadow border-l-4 border-red-500';
            errorDiv.classList.remove('hidden');
            errorText.value = errorMessage;
            // Auto-resize textarea
            errorText.style.height = 'auto';
            errorText.style.height = Math.min(errorText.scrollHeight, 100) + 'px';
        }

        function copyError(id) {
            const errorText = document.getElementById(`errorText-${id}`);
            if (errorText) {
                navigator.clipboard.writeText(errorText.value).then(() => {
                    // Brief visual feedback
                    const btn = errorText.parentElement.querySelector('button');
                    const originalText = btn.textContent;
                    btn.textContent = 'Copied!';
                    setTimeout(() => btn.textContent = originalText, 1000);
                }).catch(() => {
                    // Fallback for older browsers
                    errorText.select();
                    document.execCommand('copy');
                });
            }
        }

        async function trimVideo(id) {
            const startInput = document.getElementById(`start-${id}`);
            const endInput = document.getElementById(`end-${id}`);
            const progressDiv = document.getElementById(`progress-${id}`);
            const progressBar = document.getElementById(`progressBar-${id}`);
            const downloadDiv = document.getElementById(`download-${id}`);
            const statusDiv = document.getElementById(`status-${id}`);
            const card = document.getElementById(`card-${id}`);

            // Update status
            statusDiv.textContent = 'Trimming...';
            statusDiv.className = 'text-sm text-blue-600 font-medium';
            card.className = 'bg-white rounded-lg p-4 shadow border-l-4 border-blue-500';

            progressDiv.classList.remove('hidden');
            downloadDiv.classList.add('hidden');
            progressBar.style.width = '30%';

            const errorDiv = document.getElementById(`error-${id}`);
            const errorText = document.getElementById(`errorText-${id}`);

            try {
                const nameInput = document.getElementById(`name-${id}`);
                const response = await fetch('/trim', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        id: id,
                        start: startInput.value,
                        end: endInput.value,
                        output_name: nameInput.value
                    })
                });

                progressBar.style.width = '100%';

                const text = await response.text();
                let data;
                try {
                    data = JSON.parse(text);
                } catch (parseError) {
                    throw new Error('Server error: ' + (text || 'No response'));
                }

                if (response.ok) {
                    setTimeout(() => {
                        progressDiv.classList.add('hidden');
                        errorDiv.classList.add('hidden');
                        downloadDiv.classList.remove('hidden');

                        // Calculate trimmed duration
                        const startSecs = parseTimestamp(startInput.value);
                        const endSecs = parseTimestamp(endInput.value);
                        const trimmedDuration = formatTime(endSecs - startSecs);

                        statusDiv.textContent = `Complete - Duration: ${trimmedDuration}`;
                        statusDiv.className = 'text-sm text-green-600 font-medium';
                        card.className = 'bg-white rounded-lg p-4 shadow border-l-4 border-green-500';
                    }, 500);
                } else {
                    progressDiv.classList.add('hidden');
                    showError(id, data.error, statusDiv, card, errorDiv, errorText);
                }
            } catch (error) {
                progressDiv.classList.add('hidden');
                showError(id, error.message, statusDiv, card, errorDiv, errorText);
            }
        }

        function missedEntry(id) {
            const statusDiv = document.getElementById(`status-${id}`);
            const card = document.getElementById(`card-${id}`);
            const downloadDiv = document.getElementById(`download-${id}`);

            // Update status
            statusDiv.textContent = 'Missed Entry - Duration: 0.000s';
            statusDiv.className = 'text-sm text-yellow-600 font-medium';
            card.className = 'bg-white rounded-lg p-4 shadow border-l-4 border-yellow-500';

            // Hide download
            downloadDiv.classList.add('hidden');

            // Store missed entry state
            if (videos[id]) {
                videos[id].missedEntry = true;
                videos[id].trimmedDuration = 0;
            }
        }

        function canopyDown(id) {
            const statusDiv = document.getElementById(`status-${id}`);
            const card = document.getElementById(`card-${id}`);
            const downloadDiv = document.getElementById(`download-${id}`);

            // Update status
            statusDiv.textContent = 'Canopy Down - Duration: 0.000s';
            statusDiv.className = 'text-sm text-purple-600 font-medium';
            card.className = 'bg-white rounded-lg p-4 shadow border-l-4 border-purple-500';

            // Hide download
            downloadDiv.classList.add('hidden');

            // Store canopy down state
            if (videos[id]) {
                videos[id].canopyDown = true;
                videos[id].trimmedDuration = 0;
            }
        }

        async function deleteVideo(id) {
            try {
                await fetch(`/delete/${id}`, { method: 'DELETE' });
                delete videos[id];
                removeVideoCard(id);
                updateTrimAllVisibility();
                // Hide container if no videos left
                if (Object.keys(videos).length === 0) {
                    videoListContainer.classList.add('hidden');
                }
            } catch (error) {
                alert('Delete failed: ' + error.message);
            }
        }

        function exportCSV() {
            const rows = [['Filename', 'Start', 'End', 'Duration', 'Status', 'G1 Judgement']];

            for (const id of Object.keys(videos)) {
                const video = videos[id];
                const nameInput = document.getElementById(`name-${id}`);
                const startInput = document.getElementById(`start-${id}`);
                const endInput = document.getElementById(`end-${id}`);
                const statusDiv = document.getElementById(`status-${id}`);

                const filename = nameInput ? nameInput.value : video.filename;
                const start = startInput ? startInput.value : '0s';
                const end = endInput ? endInput.value : video.duration_str;

                let duration = '0.000s';
                let status = 'Pending';
                let g1Judgement = '';

                if (video.missedEntry) {
                    duration = '0.000s';
                    status = 'Missed Entry';
                } else if (video.canopyDown) {
                    duration = '0.000s';
                    status = 'Canopy Down';
                } else if (video.flaggedForReview) {
                    const startSecs = parseTimestamp(start);
                    const endSecs = parseTimestamp(end);
                    if (endSecs > startSecs) {
                        duration = formatTime(endSecs - startSecs) + '*';
                    }
                    status = 'Flagged for Review';
                    g1Judgement = '';
                } else if (statusDiv && statusDiv.textContent.includes('Complete')) {
                    const startSecs = parseTimestamp(start);
                    const endSecs = parseTimestamp(end);
                    duration = formatTime(endSecs - startSecs);
                    status = 'Trimmed';
                } else if (statusDiv) {
                    status = statusDiv.textContent;
                }

                rows.push([filename, start, end, duration, status, g1Judgement]);
            }

            const csvContent = rows.map(row =>
                row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(',')
            ).join('\n');

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', 'video_trim_times.csv');
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        // Preview functionality
        const previewModal = document.getElementById('previewModal');
        const previewVideoEl = document.getElementById('previewVideo');
        const previewFilename = document.getElementById('previewFilename');
        const currentTimeDisplay = document.getElementById('currentTime');
        const previewStartDisplay = document.getElementById('previewStart');
        const previewEndDisplay = document.getElementById('previewEnd');
        let currentPreviewId = null;

        // Sync filename changes from preview to main card
        previewFilename.addEventListener('input', () => {
            if (currentPreviewId) {
                const nameInput = document.getElementById(`name-${currentPreviewId}`);
                if (nameInput) {
                    nameInput.value = previewFilename.value;
                }
            }
        });

        function formatTime(seconds) {
            const totalSecs = Math.floor(seconds);
            const ms = Math.floor((seconds % 1) * 1000);
            return `${totalSecs}.${ms.toString().padStart(3, '0')}s`;
        }

        function parseTimestamp(timestamp) {
            // Remove 's' suffix if present
            const clean = timestamp.replace('s', '');
            return parseFloat(clean);
        }

        async function previewVideo(id) {
            currentPreviewId = id;
            const video = videos[id];
            // Get current filename from main card input (may have been edited)
            const nameInput = document.getElementById(`name-${id}`);
            previewFilename.value = nameInput ? nameInput.value : video.filename;
            document.getElementById('videoError').classList.add('hidden');

            // Reset video element
            previewVideoEl.pause();
            previewVideoEl.currentTime = 0;

            // Check if a preview already exists or if original is playable
            try {
                const statusRes = await fetch(`/preview/status/${id}`);
                const status = await statusRes.json();

                // Add cache-busting timestamp
                const ts = Date.now();
                if (status.use_preview || status.exists) {
                    previewVideoEl.src = `/preview/${id}?t=${ts}`;
                } else {
                    previewVideoEl.src = `/video/${id}?t=${ts}`;
                }
            } catch {
                // Fallback to original video
                previewVideoEl.src = `/video/${id}`;
            }

            previewVideoEl.load();

            // Try to play after load
            previewVideoEl.onloadeddata = () => {
                previewVideoEl.play().catch(() => {});
            };

            // Show current start/end values
            const startInput = document.getElementById(`start-${id}`);
            const endInput = document.getElementById(`end-${id}`);
            previewStartDisplay.textContent = startInput.value;
            previewEndDisplay.textContent = endInput.value;

            previewModal.classList.add('active');

            // Fetch video duration from server (works even if preview doesn't)
            fetch(`/duration/${id}`)
                .then(r => r.json())
                .then(data => {
                    if (data.duration > 0) {
                        // Update end time if it's still at 0
                        if (endInput.value === '0.000s' || endInput.value === '0s') {
                            endInput.value = data.duration_str;
                            previewEndDisplay.textContent = data.duration_str;
                        }
                        // Show duration in the current time display area
                        document.getElementById('videoDuration').textContent = data.duration_str;
                        updateTrimDuration();
                    }
                })
                .catch(() => {});

            // Try to play, but don't fail if autoplay is blocked
            previewVideoEl.play().catch(() => {});

            // Update trim duration display
            updateTrimDuration();
        }

        function closePreview() {
            previewModal.classList.remove('active');
            previewVideoEl.pause();
            previewVideoEl.src = '';
            currentPreviewId = null;
        }

        function openVideoInNewTab() {
            if (currentPreviewId) {
                const url = previewVideoEl.src || `/preview/${currentPreviewId}`;
                window.open(url, '_blank');
            }
        }

        previewVideoEl.addEventListener('timeupdate', () => {
            currentTimeDisplay.textContent = formatTime(previewVideoEl.currentTime);
        });

        previewVideoEl.addEventListener('error', (e) => {
            // Only show error if there's actually an error with the video
            if (previewVideoEl.error && currentPreviewId) {
                const errorDiv = document.getElementById('videoError');
                errorDiv.classList.remove('hidden');

                // Auto-poll for preview to be ready
                autoLoadPreview(currentPreviewId);
            }
        });

        async function autoLoadPreview(videoId) {
            const errorDiv = document.getElementById('videoError');
            const statusText = document.getElementById('previewStatusText');

            const checkAndLoad = async () => {
                if (currentPreviewId !== videoId) return; // User closed or switched video

                try {
                    const res = await fetch(`/preview/status/${videoId}`);
                    const data = await res.json();

                    if (data.exists) {
                        // Preview is ready, load it
                        statusText.innerHTML = '<span class="text-green-600">Preview ready, loading...</span>';
                        previewVideoEl.src = `/preview/${videoId}`;
                        previewVideoEl.load();

                        previewVideoEl.oncanplay = () => {
                            errorDiv.classList.add('hidden');
                            previewVideoEl.play().catch(() => {});
                        };
                    } else {
                        // Still transcoding, check again
                        statusText.innerHTML = '<span class="inline-block animate-spin mr-1">⟳</span> Generating playable preview...';
                        setTimeout(checkAndLoad, 2000);
                    }
                } catch {
                    // Retry on error
                    setTimeout(checkAndLoad, 3000);
                }
            };

            checkAndLoad();
        }

        previewVideoEl.addEventListener('loadeddata', () => {
            document.getElementById('videoError').classList.add('hidden');
        });

        previewVideoEl.addEventListener('canplay', () => {
            document.getElementById('videoError').classList.add('hidden');
        });

        function setStartFromPlayer() {
            if (currentPreviewId) {
                const time = formatTime(previewVideoEl.currentTime);
                const startInput = document.getElementById(`start-${currentPreviewId}`);
                startInput.value = time;
                previewStartDisplay.textContent = time;

                // Flash feedback
                previewStartDisplay.classList.add('text-green-600', 'font-bold');
                setTimeout(() => previewStartDisplay.classList.remove('text-green-600', 'font-bold'), 300);

                updateTrimDuration();
            }
        }

        function setEndFromPlayer() {
            if (currentPreviewId) {
                const time = formatTime(previewVideoEl.currentTime);
                const endInput = document.getElementById(`end-${currentPreviewId}`);
                endInput.value = time;
                previewEndDisplay.textContent = time;

                // Flash feedback
                previewEndDisplay.classList.add('text-red-600', 'font-bold');
                setTimeout(() => previewEndDisplay.classList.remove('text-red-600', 'font-bold'), 300);

                updateTrimDuration();
            }
        }

        function jumpToStart() {
            if (currentPreviewId) {
                const startInput = document.getElementById(`start-${currentPreviewId}`);
                const startSecs = parseTimestamp(startInput.value);
                previewVideoEl.currentTime = startSecs;
            }
        }

        function jumpToEnd() {
            if (currentPreviewId) {
                const endInput = document.getElementById(`end-${currentPreviewId}`);
                const endSecs = parseTimestamp(endInput.value);
                previewVideoEl.currentTime = endSecs;
            }
        }

        function updateTrimDuration() {
            if (currentPreviewId) {
                const startInput = document.getElementById(`start-${currentPreviewId}`);
                const endInput = document.getElementById(`end-${currentPreviewId}`);
                const startSecs = parseTimestamp(startInput.value);
                const endSecs = parseTimestamp(endInput.value);
                const duration = Math.max(0, endSecs - startSecs);
                document.getElementById('previewTrimDuration').textContent = formatTime(duration);
            }
        }

        function saveTimesOnly() {
            if (currentPreviewId) {
                const id = currentPreviewId;
                const startInput = document.getElementById(`start-${id}`);
                const endInput = document.getElementById(`end-${id}`);
                const statusDiv = document.getElementById(`status-${id}`);

                // Calculate and show duration
                const startSecs = parseTimestamp(startInput.value);
                const endSecs = parseTimestamp(endInput.value);
                const duration = formatTime(endSecs - startSecs);

                statusDiv.textContent = `Times saved - Duration: ${duration}`;
                statusDiv.className = 'text-sm text-blue-600 font-medium';

                // Store that times were saved
                if (videos[id]) {
                    videos[id].timesSaved = true;
                    videos[id].savedDuration = endSecs - startSecs;
                }

                closePreview();
            }
        }

        function saveTimesAndClose() {
            const idToTrim = currentPreviewId;
            closePreview();
            // Auto trim after closing
            if (idToTrim) {
                trimVideo(idToTrim);
            }
        }

        function missedEntryFromPreview() {
            if (currentPreviewId) {
                const id = currentPreviewId;
                closePreview();
                missedEntry(id);
            }
        }

        function canopyDownFromPreview() {
            if (currentPreviewId) {
                const id = currentPreviewId;
                closePreview();
                canopyDown(id);
            }
        }

        function flagForReviewFromPreview() {
            if (currentPreviewId) {
                const id = currentPreviewId;
                closePreview();
                flagForReview(id);
            }
        }

        function flagForReview(id) {
            const statusDiv = document.getElementById(`status-${id}`);
            const card = document.getElementById(`card-${id}`);
            const startInput = document.getElementById(`start-${id}`);
            const endInput = document.getElementById(`end-${id}`);

            // Calculate duration if start/end are set
            let durationText = '';
            if (startInput && endInput) {
                const startSecs = parseTimestamp(startInput.value);
                const endSecs = parseTimestamp(endInput.value);
                if (endSecs > startSecs) {
                    const duration = formatTime(endSecs - startSecs);
                    durationText = ` - Duration: ${duration}*`;
                }
            }

            // Update status
            statusDiv.textContent = `Flagged for Review${durationText}`;
            statusDiv.className = 'text-sm text-orange-600 font-medium';
            card.className = 'bg-white rounded-lg p-4 shadow border-l-4 border-orange-500';

            // Store flagged state
            if (videos[id]) {
                videos[id].flaggedForReview = true;
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closePreview();
                return;
            }

            // Only handle shortcuts when modal is open and not typing in an input
            if (!previewModal.classList.contains('active')) return;
            if (e.target.tagName === 'INPUT') return;

            const FRAME_TIME = 1/100; // 0.01 seconds per step for fine control

            switch(e.key.toLowerCase()) {
                case 'm':
                    e.preventDefault();
                    missedEntryFromPreview();
                    break;
                case 'c':
                    e.preventDefault();
                    canopyDownFromPreview();
                    break;
                case 'f':
                    e.preventDefault();
                    flagForReviewFromPreview();
                    break;
                case 's':
                    e.preventDefault();
                    setStartFromPlayer();
                    break;
                case 'e':
                    e.preventDefault();
                    setEndFromPlayer();
                    break;
                case ' ':
                    e.preventDefault();
                    if (previewVideoEl.paused || previewVideoEl.ended) {
                        previewVideoEl.play().catch(() => {});
                    } else {
                        previewVideoEl.pause();
                    }
                    break;
                case 'arrowleft':
                    e.preventDefault();
                    previewVideoEl.pause();
                    previewVideoEl.currentTime = Math.max(0, previewVideoEl.currentTime - FRAME_TIME);
                    break;
                case 'arrowright':
                    e.preventDefault();
                    previewVideoEl.pause();
                    const maxTime = previewVideoEl.duration || 9999;
                    previewVideoEl.currentTime = Math.min(maxTime, previewVideoEl.currentTime + FRAME_TIME);
                    break;
                case 'enter':
                    e.preventDefault();
                    saveTimesOnly();
                    break;
            }
        });

        // Close modal on backdrop click
        previewModal.addEventListener('click', (e) => {
            if (e.target === previewModal) closePreview();
        });
    </script>
</body>
</html>
